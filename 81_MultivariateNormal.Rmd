# Distribución normal multivariada {#normalmulti}

En este capítulo se mostrarán aspectos importantes de la distribución normal multivariada.

## Función de densidad

La distribución MultiVariate Normal (MVN) tiene dos parámetros, pero cada uno de estos dos parámetros contiene más de una pieza de información. Un parámetro, $\mu$, describe la ubicación o punto central de la distribución, mientras que el otro parámetro determina la dispersión, el ancho de la propagación de lado a lado en los puntos observados.

```{r normmultidensi, fig.cap='Densidad de una normal bivariada.', fig.height=7, fig.width=8, echo=FALSE}
library(mvtnorm)
N <- 100
meanX <- c(0, 0)
varX <- matrix ( c( 1, 0, 0, 1), nrow=2 , byrow = TRUE) 
x1 <- seq( meanX[1]-3*varX[1,1], meanX[1]+3*varX[1,1], length.out=N)
x2 <- seq(  meanX[2]-3*varX[2,2], meanX[2]+3*varX[2,2] , length.out=N)

myProbX <- function(x1, x2){
  dmvnorm( cbind(x1,x2), mean = meanX, sigma= varX)  
}

probX <- outer(x1, x2, FUN="myProbX")

persp(x1, x2, probX, theta = 140, phi = 10, zlim=c(0,.25), xlab="X1",ylab="X2", zlab="Densidad", ticktype="detailed")
```

En la densidad Normal multivariada, hay dos parámetros, $\mu$
y $\Sigma$. El primero es un vector de columna $n\times1$ de parámetros de ubicación y una $n\times n$ matriz de dispersión $\Sigma$.

\begin{eqnarray}
f(y_{i}|\mu,\Sigma) & =\nonumber \\
 & = & f((y_{i1},y_{i2},...,y_{in})'\,|\,\mu=(\mu_{1},...,\mu_{n})',\Sigma=\left[\begin{array}{ccc}
\sigma_{1}^{2} &  & \sigma_{1n}\\
 & \ddots\\
\sigma_{n1} &  & \sigma_{n}^{2}
\end{array}\right])\nonumber \\
 &  & =\frac{1}{\sqrt{(2\pi)^{n}|\Sigma|}}exp(-\frac{1}{2}(y_{i}-\mu)'\Sigma^{-1}(y_{i}-\mu))
\end{eqnarray}

El símbolo $|\Sigma|$ se refiere al determinante de la matriz $\Sigma$. El determinante es un solo número real. El símbolo $\Sigma^{-1}$ es el inverso de $\Sigma,$ una matriz para la cual $\Sigma\Sigma^{-1}=I.$ Esta ecuación asume que $\Sigma$ se puede invertir, y una condición suficiente para la existencia de una inversa es que el determinante no sea $0$.

La matriz $\Sigma$ debe ser semidefinida positiva para asegurar
que el punto más probable es $\mu=(\mu_{1},\mu_{2},\ldots,\mu_{n})$
y que, a medida que $y_{i}$ se aleja de $\mu$ en cualquier dirección, entonces la probabilidad de observar $y_{i}$ disminuye.

El denominador en la fórmula del MVN es una constante de normalización, que nos asegura que la distribución se integra a 1.0.


## Simulando de una normal multivariada

Para simular de una normal multivariada se puede usar la función `mvrnorm` del paquete **MASS** [@R-MASS].

A continuación vamos a simular cien observaciones de peso y estatura con un vector de medias $\mathbf{\mu}^\top=(65, 165)$ y matriz de varianzas/covarianzas

$$
\mathbf{\Sigma}=
\begin{pmatrix}
20 & 21 \\
21 & 30
\end{pmatrix}
$$


```{r dispDatosSimul, fig.cap='Densidad de una normal bivariada.', fig.height=7, fig.width=8, message=FALSE}
require(MASS)

set.seed(1974)
n <- 100
mu <- c(65, 165)
Sigma <- matrix(c(20, 21, 
                  21, 30), ncol=2, nrow=2)
datos <- mvrnorm(n=n, mu=mu, Sigma=Sigma)
plot(datos, xlab="Peso [kg]", ylab="Estatura [cm]")
points(x=mu[1], y=mu[2], lwd=5, col="tomato", pch=3)
```

## Calculando probabilidades

El paquete **mvtnorm** [@R-mvtnorm] calcula probabilidades, cuantiles, densidades y genera números aleatorios para las distribuciones multivariadas normales y $t$.

La función `pmvnorm` del paquete **mvtnorm** sirve para calcular probabilidades. [Este enlace](https://cran.r-project.org/web/packages/mvtnorm/) lo llevará a la página oficial del paquete donde se puede encontrar una viñeta con información sobre el cálculo de probabilidades.

El siguiente código fue tomado de la viñeta del paquete e ilustra la forma de calcular la probabilidad $P()$ para una normal con $\mathbf{\mu}$ y $\mathbf{\Sigma}$ como se muestran en el código.

$$
P(-\infty < X_1 \leq 1, -\infty < X_2 \leq 4, -\infty < X_3 \leq 2)
$$

```{r}
library(mvtnorm)
m <- 3
sigma <- diag(3)
sigma[2,1] <- 3/5
sigma[3,1] <- 1/3
sigma[3,2] <- 11/15
pmvnorm(mean=rep(0, m), sigma=sigma, 
        lower=rep(-Inf, m), upper=c(1,4,2))
```

